/*
 * Trying to filter water mark generated by ChatGPT and other large language models 
 *
 * Filter non ASCII characters 0 <= 127 
 *
 */

use std::fs::{read, write};
use std::env;
use sha256::digest;

fn sha256_hash(bytes: &[u8]) -> String {
    let sha256_hash = digest(bytes);

    sha256_hash
}

fn main() -> Result <(), Box<dyn std::error::Error>> {

    // user args
    let argv: Vec<String> = env::args().collect();
    if argv.len() != 2 {
        println!("Please supply source code file to filter: {} <source code full path>", argv[0]);
        std::process::exit(0);
    }

    println!("\nRemoving non ASCII characters ...");

    let fstat: bool = std::fs::exists(argv[1].clone()).expect("file not found");
    if !fstat {
        println!("Error, cannot access the file, make sure it exist!");
        std::process::exit(-1);
    } else {
        // Attempting to read the file as array of u8
        let data: Vec<u8> = read(argv[1].clone())?;

        // Calculating the original file sha256 before filtering
        let original_sha256 = sha256_hash(&data);

        // I want to track non ASCII characters offset
        let mut non_ascii_offsets = Vec::new();

        // Filtering non ASCII characters 
        let filtered_bytes: Vec<u8> = data.iter()
            .enumerate()
            .filter_map(|(i, &b)| {
                if b.is_ascii() {
                    Some(b)
                } else {
                    non_ascii_offsets.push(i);
                    None
                }
            })
            .collect();

        println!("Removed {} non-ASCII bytes", non_ascii_offsets.len());
        println!("Offsets of removed bytes: {:?}", non_ascii_offsets);

        // In case there was filtering we will get different hash
        let filtered_sha256: String = sha256_hash(&filtered_bytes);
        if filtered_sha256 != original_sha256 {
            // Modifying the file if needed
            write(argv[1].clone(), &filtered_bytes)?;
        }

        println!("original sha256: {}\ndestination sha256: {}", original_sha256, filtered_sha256);
    }

    Ok(())
}
